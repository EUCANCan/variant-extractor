<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VCF variant extractor &mdash; variant-extractor 1.1.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="variant_extractor API" href="variant_extractor.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="#" class="icon icon-home"> variant-extractor
          </a>
              <div class="version">
                1.1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="variant_extractor.html">variant_extractor API</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">variant-extractor</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
      <li>VCF variant extractor<!-- omit in toc --></li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="vcf-variant-extractor-omit-in-toc">
<h1>VCF variant extractor<!-- omit in toc --><a class="headerlink" href="#vcf-variant-extractor-omit-in-toc" title="Permalink to this headline"></a></h1>
<p><strong>Deterministic and standard extractor of indels, SNVs and structural variants (SVs)</strong> from VCF files built under the frame of <a class="reference external" href="https://eucancan.com/">EUCANCan</a>’s second work package. <code class="docutils literal notranslate"><span class="pre">variant_extractor</span></code> is a Python package (<strong>requires Python version 3.6 or higher</strong>) and provides a set of classes and functions to read and extract variants from VCF files in a <strong>deterministic and standard</strong> way. Check the <a class="reference external" href="https://rapsssito.github.io/variant-extractor/">available documentation</a> for more information. The package is designed to be used in a pipeline, where the variants are ingested from VCF files and then used in downstream analysis.</p>
<p>While there is somewhat of an agreement on how to label the SNVs and indels variants, this is not the case for the structural variants. In the current scenario, different labeling between variant callers makes comparisons between structural variants difficult. This package provides an unified interface to extract variants (included structural variants) from VCFs generated by different variant callers. Apart from reading the VCF file, the <code class="docutils literal notranslate"><span class="pre">variant_extractor</span></code> <strong>adds a preprocessing layer to homogenize the variants</strong> extracted from the file. This way, the variants can be used in downstream analysis in a consistent way. For more information about the homogenization process, check the <span class="xref myst">homogenization rules</span> section.</p>
<p><strong>WARNING: VCF entries with multiple ALT values are ignored.</strong></p>
<section id="table-of-contents-omit-in-toc">
<h2>Table of contents<!-- omit in toc --><a class="headerlink" href="#table-of-contents-omit-in-toc" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p><span class="xref myst">Usage</span></p></li>
<li><p><span class="xref myst">VariantRecord</span></p>
<ul>
<li><p><span class="xref myst">BracketSVRecord</span></p></li>
<li><p><span class="xref myst">ShorthandSVRecord</span></p></li>
</ul>
</li>
<li><p><span class="xref myst">VariantType</span></p></li>
<li><p><span class="xref myst">Homogenization rules</span></p>
<ul>
<li><p><span class="xref myst">SNVs</span></p></li>
<li><p><span class="xref myst">Indels</span></p></li>
<li><p><span class="xref myst">Structural variants</span></p>
<ul>
<li><p><span class="xref myst">Bracket vs shorthand notation</span></p></li>
<li><p><span class="xref myst">Paired breakends</span></p></li>
<li><p><span class="xref myst">Imprecise paired breakends</span></p></li>
<li><p><span class="xref myst">Single breakends</span></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this headline"></a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import the package</span>
<span class="kn">from</span> <span class="nn">variant_extractor</span> <span class="kn">import</span> <span class="n">VariantExtractor</span>

<span class="c1"># Create a new instance of the class</span>
<span class="n">extractor</span> <span class="o">=</span> <span class="n">VariantExtractor</span><span class="p">()</span>
<span class="c1"># Read the VCF file</span>
<span class="n">variants</span> <span class="o">=</span> <span class="n">extractor</span><span class="o">.</span><span class="n">read_vcf</span><span class="p">(</span><span class="s1">&#39;/path/to/file.vcf&#39;</span><span class="p">)</span>
<span class="c1"># Iterate through the variants</span>
<span class="k">for</span> <span class="n">variant_type</span><span class="p">,</span> <span class="n">variant_record</span> <span class="ow">in</span> <span class="n">variants</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found variant of type </span><span class="si">{</span><span class="n">variant_type</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">variant_record</span><span class="o">.</span><span class="n">contig</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">variant_record</span><span class="o">.</span><span class="n">pos</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>For a complete list of examples, see the <span class="xref myst">examples</span> directory.</p>
</section>
<section id="variantrecord">
<h2>VariantRecord<a class="headerlink" href="#variantrecord" title="Permalink to this headline"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">VariantExtractor.read_vcf()</span></code> method returns a list of tuples of the form <code class="docutils literal notranslate"><span class="pre">(variant_type,</span> <span class="pre">variant_record)</span></code>. The <code class="docutils literal notranslate"><span class="pre">variant_type</span></code> is an instance of the <code class="docutils literal notranslate"><span class="pre">VariantType</span></code> enum, and the <code class="docutils literal notranslate"><span class="pre">variant_record</span></code> is an instance of the <code class="docutils literal notranslate"><span class="pre">VariantRecord</span></code> class. The <code class="docutils literal notranslate"><span class="pre">VariantRecord</span></code> class is a container for the information contained in a VCF record.</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">contig</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str</span></code></p></td>
<td><p>Contig name</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">pos</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>Position on the contig</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">end</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>End position of the variant in the contig (same as <code class="docutils literal notranslate"><span class="pre">pos</span></code> for TRN and SNV)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">id</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str</span></code></p></td>
<td><p>Record identifier</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">ref</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str</span></code></p></td>
<td><p>Reference sequence</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">alt</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">list</span></code></p></td>
<td><p>List of alternative sequences</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">filter</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">pysam.VariantRecordFilter</span></code></p></td>
<td><p>Filter</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">info</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">pysam.VariantRecordInfo</span></code></p></td>
<td><p>Dictionary of information fields</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">alt_sv_bracket</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Optional[BracketSVRecord]</span></code></p></td>
<td><p>Bracketed SV info, present only for SVs with bracket notation. For example, <code class="docutils literal notranslate"><span class="pre">G]17:198982]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">alt_sv_shorthand</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Optional[ShorthandSVRecord]</span></code></p></td>
<td><p>Shorthand SV info, present only for SVs with shorthand notation. For example, <code class="docutils literal notranslate"><span class="pre">&lt;DUP:TANDEM&gt;</span></code></p></td>
</tr>
</tbody>
</table>
<section id="bracketsvrecord">
<h3>BracketSVRecord<a class="headerlink" href="#bracketsvrecord" title="Permalink to this headline"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">BracketSVRecord</span></code> class is a container for the information contained in a VCF record for SVs with bracket notation.</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">prefix</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Optional[str]</span></code></p></td>
<td><p>Prefix of the SV record with bracket notation. For example, for <code class="docutils literal notranslate"><span class="pre">G]17:198982]</span></code> the prefix will be <code class="docutils literal notranslate"><span class="pre">G</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">bracket</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str</span></code></p></td>
<td><p>Bracket of the SV record with bracket notation. For example, for <code class="docutils literal notranslate"><span class="pre">G]17:198982]</span></code> the bracket will be <code class="docutils literal notranslate"><span class="pre">]</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">contig</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str</span></code></p></td>
<td><p>Contig of the SV record with bracket notation. For example, for <code class="docutils literal notranslate"><span class="pre">G]17:198982]</span></code> the contig will be <code class="docutils literal notranslate"><span class="pre">17</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">pos</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>Position of the SV record with bracket notation. For example, for <code class="docutils literal notranslate"><span class="pre">G]17:198982]</span></code> the position will be <code class="docutils literal notranslate"><span class="pre">198982</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">suffix</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Optional[str]</span></code></p></td>
<td><p>Suffix of the SV record with bracket notation. For example, for <code class="docutils literal notranslate"><span class="pre">G]17:198982]</span></code> the suffix will be <code class="docutils literal notranslate"><span class="pre">None</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="shorthandsvrecord">
<h3>ShorthandSVRecord<a class="headerlink" href="#shorthandsvrecord" title="Permalink to this headline"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ShorthandSVRecord</span></code> class is a container for the information contained in a VCF record for SVs with shorthand notation.</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Property</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">type</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">str</span></code></p></td>
<td><p>Type of the SV record with shorthand notation. One of the following, <code class="docutils literal notranslate"><span class="pre">'DEL'</span></code>, <code class="docutils literal notranslate"><span class="pre">'INS'</span></code>, <code class="docutils literal notranslate"><span class="pre">'DUP'</span></code>, <code class="docutils literal notranslate"><span class="pre">'INV'</span></code> or <code class="docutils literal notranslate"><span class="pre">'CNV'</span></code>. For example, for <code class="docutils literal notranslate"><span class="pre">&lt;DUP:TANDEM&gt;</span></code> the type will be <code class="docutils literal notranslate"><span class="pre">DUP</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">extra</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">List[str]</span></code></p></td>
<td><p>Extra information of the SV. For example, for <code class="docutils literal notranslate"><span class="pre">&lt;DUP:TANDEM:AA&gt;</span></code> the extra will be <code class="docutils literal notranslate"><span class="pre">['TANDEM',</span> <span class="pre">'AA']</span></code></p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="varianttype">
<h2>VariantType<a class="headerlink" href="#varianttype" title="Permalink to this headline"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">VariantType</span></code> enum is a container for the information about the type of the variant. For structural variants is inferred <strong>only</strong> from the bracket notation, it does not take into account any <code class="docutils literal notranslate"><span class="pre">INFO</span></code> (fields <code class="docutils literal notranslate"><span class="pre">SVTYPE</span></code> or <code class="docutils literal notranslate"><span class="pre">EVENTYPE</span></code>).</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>REF</p></th>
<th class="head"><p>ALT</p></th>
<th class="head"><p>Variant name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>A</p></td>
<td><p>G</p></td>
<td><p>SNV</p></td>
<td><p>Single nucleotide variant</p></td>
</tr>
<tr class="row-odd"><td><p>AGTG</p></td>
<td><p>A</p></td>
<td><p>INDEL_DEL</p></td>
<td><p>Indel deletion</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>ACCT</p></td>
<td><p>INDEL_INS</p></td>
<td><p>Indel insertion</p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>A[1:20[ or &lt;DEL&gt;</p></td>
<td><p>DEL</p></td>
<td><p>Deletion</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>&lt;INS&gt;</p></td>
<td><p>INS</p></td>
<td><p>Insertion</p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>]1:20]a or &lt;DUP&gt;</p></td>
<td><p>DUP</p></td>
<td><p>Duplication</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>A]1:20] or [1:20[A</p></td>
<td><p>INV</p></td>
<td><p>Inversion. <strong><span class="xref myst">&lt;INV&gt; is a special case</span></strong></p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>&lt;CNV&gt;</p></td>
<td><p>CNV</p></td>
<td><p>Copy number variation</p></td>
</tr>
<tr class="row-even"><td><p>A</p></td>
<td><p>A]X:20] or A[X:20[ or ]X:20]A or [X:20[A</p></td>
<td><p>TRN</p></td>
<td><p>Translocation</p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>A. or .A</p></td>
<td><p>SGL</p></td>
<td><p>Single breakend</p></td>
</tr>
</tbody>
</table>
</section>
<section id="homogenization-rules">
<h2>Homogenization rules<a class="headerlink" href="#homogenization-rules" title="Permalink to this headline"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">variant_extractor</span></code> package provides a unified interface to extract variants (included structural variants) from VCF files generated by different variant callers. The variants are homogenized and returned applying the following rules:</p>
<section id="snvs">
<h3>SNVs<a class="headerlink" href="#snvs" title="Permalink to this headline"></a></h3>
<p>Entries with <code class="docutils literal notranslate"><span class="pre">REF/ALT</span></code> of the same lenghts are treated like SNVs. If the <code class="docutils literal notranslate"><span class="pre">REF/ALT</span></code> sequences are more than one nucleotide, they are divided into multiple SNVs. For example:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>CHROM</p></th>
<th class="head"><p>POS</p></th>
<th class="head"><p>ID</p></th>
<th class="head"><p>REF</p></th>
<th class="head"><p>ALT</p></th>
<th class="head"><p>FILTER</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>1</p></td>
<td><p>event_1</p></td>
<td><p>C</p></td>
<td><p>G</p></td>
<td><p>PASS</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>3</p></td>
<td><p>event_2</p></td>
<td><p>TAG</p></td>
<td><p>AGT</p></td>
<td><p>PASS</p></td>
</tr>
</tbody>
</table>
<p>are returned as:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>CHROM</p></th>
<th class="head"><p>POS</p></th>
<th class="head"><p>ID</p></th>
<th class="head"><p>REF</p></th>
<th class="head"><p>ALT</p></th>
<th class="head"><p>FILTER</p></th>
<th class="head"><p><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">VariantType</span></code></span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>3</p></td>
<td><p>event_1</p></td>
<td><p>C</p></td>
<td><p>G</p></td>
<td><p>PASS</p></td>
<td><p>SNV</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>3</p></td>
<td><p>event_2_1</p></td>
<td><p>T</p></td>
<td><p>A</p></td>
<td><p>PASS</p></td>
<td><p>SNV</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>4</p></td>
<td><p>event_2_2</p></td>
<td><p>A</p></td>
<td><p>G</p></td>
<td><p>PASS</p></td>
<td><p>SNV</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>5</p></td>
<td><p>event_2_3</p></td>
<td><p>G</p></td>
<td><p>T</p></td>
<td><p>PASS</p></td>
<td><p>SNV</p></td>
</tr>
</tbody>
</table>
</section>
<section id="indels">
<h3>Indels<a class="headerlink" href="#indels" title="Permalink to this headline"></a></h3>
<p>All entries with the <code class="docutils literal notranslate"><span class="pre">REF/ALT</span></code> of different lengths are treated as indels. If the <code class="docutils literal notranslate"><span class="pre">REF</span></code> sequence is longer than the <code class="docutils literal notranslate"><span class="pre">ALT</span></code> sequence, it is considered a deletion. If the <code class="docutils literal notranslate"><span class="pre">REF</span></code> sequence is shorter than the <code class="docutils literal notranslate"><span class="pre">ALT</span></code> sequence, it is considered an insertion. For example:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>CHROM</p></th>
<th class="head"><p>POS</p></th>
<th class="head"><p>ID</p></th>
<th class="head"><p>REF</p></th>
<th class="head"><p>ALT</p></th>
<th class="head"><p>FILTER</p></th>
<th class="head"><p><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">VariantType</span></code></span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>3</p></td>
<td><p>event_1</p></td>
<td><p>T</p></td>
<td><p>TGT</p></td>
<td><p>PASS</p></td>
<td><p>INDEL_INS</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>10</p></td>
<td><p>event_2</p></td>
<td><p>TA</p></td>
<td><p>AAT</p></td>
<td><p>PASS</p></td>
<td><p>INDEL_INS</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>5</p></td>
<td><p>event_3</p></td>
<td><p>TAG</p></td>
<td><p>T</p></td>
<td><p>PASS</p></td>
<td><p>INDEL_DEL</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>8</p></td>
<td><p>event_4</p></td>
<td><p>TAG</p></td>
<td><p>AG</p></td>
<td><p>PASS</p></td>
<td><p>INDEL_DEL</p></td>
</tr>
</tbody>
</table>
</section>
<section id="structural-variants">
<h3>Structural variants<a class="headerlink" href="#structural-variants" title="Permalink to this headline"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">variant_extractor</span></code> returns one entry per structural variant (one entry per breakend pair). This helps to avoid the ambiguity of the notation and keeps the process deterministic. Also, for this reason, in case of paired breakends, the breakend with the lowest chromosome and/or position is returned.</p>
<section id="bracket-vs-shorthand-notation">
<h4>Bracket vs shorthand notation<a class="headerlink" href="#bracket-vs-shorthand-notation" title="Permalink to this headline"></a></h4>
<p>Entries with the same information, either described with shorthand or bracket notation, will be tagged the same way. Here is an example for a DEL entry:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>CHROM</p></th>
<th class="head"><p>POS</p></th>
<th class="head"><p>ID</p></th>
<th class="head"><p>REF</p></th>
<th class="head"><p>ALT</p></th>
<th class="head"><p>FILTER</p></th>
<th class="head"><p>INFO</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>3000</p></td>
<td><p>event_1_o</p></td>
<td><p>A</p></td>
<td><p>A[1:5000[</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=BND</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>5000</p></td>
<td><p>event_1_h</p></td>
<td><p>A</p></td>
<td><p>]1:3000]A</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=BND</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>3000</p></td>
<td><p>event_1</p></td>
<td><p>A</p></td>
<td><p>A[1:5000[</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=DEL</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>3000</p></td>
<td><p>event_1</p></td>
<td><p>A</p></td>
<td><p>&lt;DEL&gt;</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=DEL; END=5000</p></td>
</tr>
</tbody>
</table>
<p>are returned as one entry (each one of them with their own <code class="docutils literal notranslate"><span class="pre">ALT</span></code> field), but with the same <code class="docutils literal notranslate"><span class="pre">VariantRecord.end</span></code> and <code class="docutils literal notranslate"><span class="pre">VariantType</span></code>:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>CHROM</p></th>
<th class="head"><p>POS</p></th>
<th class="head"><p>ID</p></th>
<th class="head"><p>REF</p></th>
<th class="head"><p>ALT</p></th>
<th class="head"><p>FILTER</p></th>
<th class="head"><p>INFO</p></th>
<th class="head"><p><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">VariantType</span></code></span></p></th>
<th class="head"><p><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">VariantRecord.end</span></code></span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>3000</p></td>
<td><p>event_1</p></td>
<td><p>A</p></td>
<td><p>…</p></td>
<td><p>PASS</p></td>
<td><p>…</p></td>
<td><p>DEL</p></td>
<td><p>5000</p></td>
</tr>
</tbody>
</table>
<section id="inv-special-case-omit-in-toc">
<h5>INV special case<!-- omit in toc --><a class="headerlink" href="#inv-special-case-omit-in-toc" title="Permalink to this headline"></a></h5>
<p>&lt;INV&gt; is a special case of shorthand notation because it represents two paired breakends. For example, the following shorthand notation:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>CHROM</p></th>
<th class="head"><p>POS</p></th>
<th class="head"><p>ID</p></th>
<th class="head"><p>REF</p></th>
<th class="head"><p>ALT</p></th>
<th class="head"><p>FILTER</p></th>
<th class="head"><p>INFO</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>321682</p></td>
<td><p>INV0</p></td>
<td><p>T</p></td>
<td><p>&lt;INV&gt;</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=INV;END=421681</p></td>
</tr>
</tbody>
</table>
<p>is equivalent to the following breakends:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>CHROM</p></th>
<th class="head"><p>POS</p></th>
<th class="head"><p>ID</p></th>
<th class="head"><p>REF</p></th>
<th class="head"><p>ALT</p></th>
<th class="head"><p>FILTER</p></th>
<th class="head"><p>INFO</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>321681</p></td>
<td><p>event_1</p></td>
<td><p>.</p></td>
<td><p>.]2:421681]</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=BND</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>321682</p></td>
<td><p>event_1</p></td>
<td><p>T</p></td>
<td><p>[2:421682[T</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=BND</p></td>
</tr>
</tbody>
</table>
<p>In this case, <code class="docutils literal notranslate"><span class="pre">variant_extractor</span></code> converts internally &lt;INV&gt; to two entries with bracket notation (one for each breakend pair).</p>
</section>
</section>
<section id="paired-breakends">
<h4>Paired breakends<a class="headerlink" href="#paired-breakends" title="Permalink to this headline"></a></h4>
<p>For <strong>paired breakends</strong>, breakends are paired using their coordinates (contig+position). The breakend with the lowest chromosome and/or position is returned. For example:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>CHROM</p></th>
<th class="head"><p>POS</p></th>
<th class="head"><p>ID</p></th>
<th class="head"><p>REF</p></th>
<th class="head"><p>ALT</p></th>
<th class="head"><p>FILTER</p></th>
<th class="head"><p>INFO</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>3000</p></td>
<td><p>event_1_o</p></td>
<td><p>T</p></td>
<td><p>T[3:5000[</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=BND</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>5000</p></td>
<td><p>event_1_h</p></td>
<td><p>T</p></td>
<td><p>]2:3000]T</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=BND</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>3000</p></td>
<td><p>event_2_o</p></td>
<td><p>A</p></td>
<td><p>A[1:5000[</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=BND</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>5000</p></td>
<td><p>event_2_h</p></td>
<td><p>A</p></td>
<td><p>]1:3000]A</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=BND</p></td>
</tr>
</tbody>
</table>
<p>are returned as one entry per variant:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>CHROM</p></th>
<th class="head"><p>POS</p></th>
<th class="head"><p>ID</p></th>
<th class="head"><p>REF</p></th>
<th class="head"><p>ALT</p></th>
<th class="head"><p>FILTER</p></th>
<th class="head"><p>INFO</p></th>
<th class="head"><p><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">VariantType</span></code></span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>3000</p></td>
<td><p>event_1_o</p></td>
<td><p>T</p></td>
<td><p>T[3:5000[</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=BND</p></td>
<td><p>TRN</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>3000</p></td>
<td><p>event_2_o</p></td>
<td><p>A</p></td>
<td><p>A[1:5000[</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=BND</p></td>
<td><p>DEL</p></td>
</tr>
</tbody>
</table>
</section>
<section id="imprecise-paired-breakends">
<h4>Imprecise paired breakends<a class="headerlink" href="#imprecise-paired-breakends" title="Permalink to this headline"></a></h4>
<p>Imprecise breakends with bracket notation are paired using the <code class="docutils literal notranslate"><span class="pre">INFO</span></code> fields <code class="docutils literal notranslate"><span class="pre">MATEID</span></code> or <code class="docutils literal notranslate"><span class="pre">PARID</span></code> instead of their coordinates (since they may not match). In order to keep the deterministic process, as with the rest of variants, only the breakend with the lowest chromosome and/or position is returned. However, it is important to notice that the uncertainty information (<code class="docutils literal notranslate"><span class="pre">CIPOS</span></code> field) is lost for the other breakend. For example:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>CHROM</p></th>
<th class="head"><p>POS</p></th>
<th class="head"><p>ID</p></th>
<th class="head"><p>REF</p></th>
<th class="head"><p>ALT</p></th>
<th class="head"><p>FILTER</p></th>
<th class="head"><p>INFO</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>3010</p></td>
<td><p>event_1_o</p></td>
<td><p>T</p></td>
<td><p>T[3:5000[</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=BND;CIPOS=0,50;PARID=a_h</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>5050</p></td>
<td><p>event_1_h</p></td>
<td><p>T</p></td>
<td><p>]2:3050]T</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=BND;CIPOS=0,100;PARID=a_o</p></td>
</tr>
</tbody>
</table>
<p>are returned as one entry:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>CHROM</p></th>
<th class="head"><p>POS</p></th>
<th class="head"><p>ID</p></th>
<th class="head"><p>REF</p></th>
<th class="head"><p>ALT</p></th>
<th class="head"><p>FILTER</p></th>
<th class="head"><p>INFO</p></th>
<th class="head"><p><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">VariantType</span></code></span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>3010</p></td>
<td><p>event_1_o</p></td>
<td><p>T</p></td>
<td><p>T[3:5000[</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=BND;CIPOS=0,50;PARID=a_h</p></td>
<td><p>TRN</p></td>
</tr>
</tbody>
</table>
</section>
<section id="single-breakends">
<h4>Single breakends<a class="headerlink" href="#single-breakends" title="Permalink to this headline"></a></h4>
<p>Single breakends cannot be matched with other breakends because they lack a mate. That is why each one is kept as a different variant. For example:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>CHROM</p></th>
<th class="head"><p>POS</p></th>
<th class="head"><p>ID</p></th>
<th class="head"><p>REF</p></th>
<th class="head"><p>ALT</p></th>
<th class="head"><p>FILTER</p></th>
<th class="head"><p>INFO</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>3000</p></td>
<td><p>a_s</p></td>
<td><p>T</p></td>
<td><p>T.</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=BND</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>5000</p></td>
<td><p>m_s</p></td>
<td><p>G</p></td>
<td><p>.G</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=BND</p></td>
</tr>
</tbody>
</table>
<p>are be returned as two entries:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>CHROM</p></th>
<th class="head"><p>POS</p></th>
<th class="head"><p>ID</p></th>
<th class="head"><p>REF</p></th>
<th class="head"><p>ALT</p></th>
<th class="head"><p>FILTER</p></th>
<th class="head"><p>INFO</p></th>
<th class="head"><p><span class="xref myst"><code class="docutils literal notranslate"><span class="pre">VariantType</span></code></span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2</p></td>
<td><p>3000</p></td>
<td><p>a_s</p></td>
<td><p>T</p></td>
<td><p>T.</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=BND</p></td>
<td><p>SGL</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>5000</p></td>
<td><p>m_s</p></td>
<td><p>G</p></td>
<td><p>.G</p></td>
<td><p>PASS</p></td>
<td><p>SVTYPE=BND</p></td>
<td><p>SGL</p></td>
</tr>
</tbody>
</table>
</section>
</section>
</section>
</section>
<div class="toctree-wrapper compound">
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="variant_extractor.html">variant_extractor API</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="changelog.html#v1-1-0-2022-03-23">v1.1.0 (2022-03-23)</a></li>
<li class="toctree-l2"><a class="reference internal" href="changelog.html#v0-1-0-2022-03-17">v0.1.0 (2022-03-17)</a></li>
</ul>
</li>
</ul>
</div>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline"></a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="variant_extractor.html" class="btn btn-neutral float-right" title="variant_extractor API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Rapsssito.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>