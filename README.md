# VCF variant extractor <!-- omit in toc -->
**Deterministic and standard extractor of indels, SNVs and structural variants (SVs)** from VCF files built under the frame of [EUCANCan](https://eucancan.com/)'s second work package. `variant_extractor` is a Python package (**requires Python version 3.6 or higher**) and provides a set of classes and functions to read and extract variants from VCF files in a **deterministic and standard** way. Check the [available documentation](https://rapsssito.github.io/variant-extractor/) for more information. The package is designed to be used in a pipeline, where the variants are ingested from VCF files and then used in downstream analysis.

While there is somewhat of an agreement on how to label the SNVs and indels variants, this is not the case for the structural variants. In the current scenario, different labeling between variant callers makes comparisons between structural variants difficult. This package provides an unified interface to extract variants (included structural variants) from VCFs generated by different variant callers. Apart from reading the VCF file, the `variant_extractor` **adds a preprocessing layer to homogenize the variants** extracted from the file. This way, the variants can be used in downstream analysis in a consistent way. For more information about the homogenization process, check the [homogenization rules](#homogenization-rules) section.

**WARNING: VCF entries with multiple ALT values are ignored.**

## Table of contents <!-- omit in toc -->
- [Getting started](#getting-started)
- [Usage](#usage)
- [VariantRecord](#variantrecord)
  - [BracketSVRecord](#bracketsvrecord)
  - [ShorthandSVRecord](#shorthandsvrecord)
- [VariantType](#varianttype)
- [Homogenization rules](#homogenization-rules)
  - [SNVs](#snvs)
  - [Indels](#indels)
  - [Structural variants](#structural-variants)
    - [Bracket and shorthand notation](#bracket-and-shorthand-notation)
    - [Paired breakends](#paired-breakends)
    - [Imprecise paired breakends](#imprecise-paired-breakends)
    - [Single breakends](#single-breakends)

## Getting started
Install the package using `pip`:
```
pip install variant_extractor
```

## Usage
```python
# Import the package
from variant_extractor import VariantExtractor

# Create a new instance of the class
extractor = VariantExtractor()
# Read the VCF file
variants = extractor.read_vcf('/path/to/file.vcf')
# Iterate through the variants
for variant_type, variant_record in variants:
    print(f'Found variant of type {variant_type.name()}: {variant_record.contig}:{variant_record.pos}')
```

For a complete list of examples, see the [examples](./examples/) directory.

## VariantRecord
The `VariantExtractor.read_vcf()` method returns a list of tuples of the form `(variant_type, variant_record)`. The `variant_type` is an instance of the `VariantType` enum, and the `variant_record` is an instance of the `VariantRecord` class. The `VariantRecord` class is a container for the information contained in a VCF record.

| Property           | Type                          | Description                                                                                  |
| ------------------ | ----------------------------- | -------------------------------------------------------------------------------------------- |
| `contig`           | `str`                         | Contig name                                                                                  |
| `pos`              | `int`                         | Position on the contig                                                                       |
| `end`              | `int`                         | End position of the variant in the contig (same as `pos` for TRN and SNV)                    |
| `id`               | `str`                         | Record identifier                                                                            |
| `ref`              | `str`                         | Reference sequence                                                                           |
| `alt`              | `list`                        | List of alternative sequences                                                                |
| `filter`           | `pysam.VariantRecordFilter`   | Filter                                                                                       |
| `info`             | `pysam.VariantRecordInfo`     | Dictionary of information fields                                                             |
| `alt_sv_bracket`   | `Optional[BracketSVRecord]`   | Bracketed SV info, present only for SVs with bracket notation. For example, `G]17:198982]`   |
| `alt_sv_shorthand` | `Optional[ShorthandSVRecord]` | Shorthand SV info, present only for SVs with shorthand notation. For example, `<DUP:TANDEM>` |

### BracketSVRecord
The `BracketSVRecord` class is a container for the information contained in a VCF record for SVs with bracket notation.

| Property  | Type            | Description                                                                                                    |
| --------- | --------------- | -------------------------------------------------------------------------------------------------------------- |
| `prefix`  | `Optional[str]` | Prefix of the SV record with bracket notation. For example, for `G]17:198982]` the prefix will be `G`          |
| `bracket` | `str`           | Bracket of the SV record with bracket notation. For example, for `G]17:198982]` the bracket will be `]`        |
| `contig`  | `str`           | Contig of the SV record with bracket notation. For example, for `G]17:198982]` the contig will be `17`         |
| `pos`     | `int`           | Position of the SV record with bracket notation. For example, for `G]17:198982]` the position will be `198982` |
| `suffix`  | `Optional[str]` | Suffix of the SV record with bracket notation. For example, for `G]17:198982]` the suffix will be `None`       |

### ShorthandSVRecord
The `ShorthandSVRecord` class is a container for the information contained in a VCF record for SVs with shorthand notation.

| Property | Type        | Description                                                                                                                                                                |
| -------- | ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`   | `str`       | Type of the SV record with shorthand notation. One of the following, `'DEL'`, `'INS'`, `'DUP'`, `'INV'` or `'CNV'`. For example, for `<DUP:TANDEM>` the type will be `DUP` |
| `extra`  | `List[str]` | Extra information of the SV. For example, for `<DUP:TANDEM:AA>` the extra will be `['TANDEM', 'AA']`                                                                       |

## VariantType
The `VariantType` enum is a container for the information about the type of the variant. For structural variants is inferred **only** from the bracket notation, it does not take into account any `INFO` (fields `SVTYPE` or `EVENTYPE`).

| Variant name | Bracket notation                                | Description               |
| ------------ | ----------------------------------------------- | ------------------------- |
| `SNV`        |                                                 | Single nucleotide variant |
| `INDEL_DEL`  |                                                 | Indel deletion            |
| `INDEL_INS`  |                                                 | Indel insertion           |
| `DEL`        | `1 10 N N[1:20[`                                | Deletion                  |
| `INS`        |                                                 | Insertion                 |
| `DUP`        | `1 10 N ]1:20]N`                                | Duplication               |
| `INV`        | `1 10 N N]1:20] / [1:20[N`                      | Inversion                 |
| `CNV`        |                                                 | Copy number variation     |
| `TRN`        | `1 10 N N]X:20] / N[X:20[ / ]X:20]N / [X:20[N ` | Translocation             |
| `SGL`        | `1 10 N N. / .N`                                | Single breakend           |

## Homogenization rules
The `variant_extractor` package provides a unified interface to extract variants (included structural variants) from VCF files generated by different variant callers. The variants are homogenized applying the following rules:

### SNVs
Entries with `REF/ALT` of the same lenghts are treated like multiple SNVs. For example:

| CHROM | POS | REF | ALT | FILTER |
| ----- | --- | --- | --- | ------ |
| 2     | 3   | TAG | AGT | PASS   |

Would be returned as:

| CHROM | POS | REF | ALT | FILTER | VAR_TYPE |
| ----- | --- | --- | --- | ------ | -------- |
| 2     | 3   | T   | A   | PASS   | SNV      |
| 2     | 4   | A   | G   | PASS   | SNV      |
| 2     | 5   | G   | T   | PASS   | SNV      |

### Indels
All entries with the following format would be treated as indels:

| CHROM | POS | REF | ALT | FILTER | VAR_TYPE  |
| ----- | --- | --- | --- | ------ | --------- |
| 2     | 3   | T   | TGT | PASS   | INDEL_INS |
| 2     | 10  | TA  | AAT | PASS   | INDEL_INS |
| 2     | 5   | TAG | T   | PASS   | INDEL_DEL |
| 2     | 8   | TAG | AG  | PASS   | INDEL_DEL |

### Structural variants
#### Bracket and shorthand notation
Entries with the same information, either described with shorthand or bracket notation, will be tagged the same way. Here is an example for a DEL entry:

| CHROM | POS  | REF | ALT       | FILTER | INFO                 |
| ----- | ---- | --- | --------- | ------ | -------------------- |
| 1     | 3000 | A   | A[1:5000[ | PASS   | SVTYPE=BND           |
| 1     | 5000 | A   | ]1:3000]A | PASS   | SVTYPE=BND           |
| 1     | 3000 | A   | A[1:5000[ | PASS   | SVTYPE=DEL           |
| 1     | 3000 | A   | \<DEL\>   | PASS   | SVTYPE=DEL; END=5000 |

All would be returned as one entry (each one of them with their own `ALT` field), but with the same `VariantRecord.end` and `VariantType`:

| CHROM | POS  | REF | ALT | FILTER | INFO | [`VariantType`](#varianttype) | [`VariantRecord.end`](#variantrecord) |
| ----- | ---- | --- | --- | ------ | ---- | ----------------------------- | ------------------------------------- |
| 2     | 3000 | A   | ... | PASS   | ...  | DEL                           | 5000                                  |

#### Paired breakends
For **paired breakends**, breakends are paired using their coordinates (contig+position). The breakend with the lowest chromosome and/or position is returned. For example:

| CHROM | ID  | POS  | REF | ALT       | FILTER | INFO       |
| ----- | --- | ---- | --- | --------- | ------ | ---------- |
| 2     | a_o | 3000 | T   | T[3:5000[ | PASS   | SVTYPE=BND |
| 3     | a_h | 5000 | T   | ]2:3000]T | PASS   | SVTYPE=BND |
| 1     | b_o | 3000 | A   | A[1:5000[ | PASS   | SVTYPE=BND |
| 1     | b_h | 5000 | A   | ]1:3000]A | PASS   | SVTYPE=BND |

Would be returned as one entry per variant:

| CHROM | ID  | POS  | REF | ALT       | FILTER | INFO       | [`VariantType`](#varianttype) |
| ----- | --- | ---- | --- | --------- | ------ | ---------- | ----------------------------- |
| 2     | a_o | 3000 | T   | T[3:5000[ | PASS   | SVTYPE=BND | TRN                           |
| 1     | b_o | 3000 | A   | A[1:5000[ | PASS   | SVTYPE=BND | DEL                           |

#### Imprecise paired breakends
Imprecise breakends with bracket notation are paired using the `INFO` fields `MATEID` or `PARID` instead of their coordinates (since they may not match). In order to keep the deterministic process, as with the rest of variants, only the breakend with the lowest chromosome and/or position is returned. However, it is important to notice that the uncertainty information (`CIPOS` field) is lost for the other breakend. For example:

| CHROM | ID  | POS  | REF | ALT       | FILTER | INFO                             |
| ----- | --- | ---- | --- | --------- | ------ | -------------------------------- |
| 2     | a_o | 3010 | T   | T[3:5000[ | PASS   | SVTYPE=BND;CIPOS=0,50;PARID=a_h  |
| 3     | a_h | 5050 | T   | ]2:3050]T | PASS   | SVTYPE=BND;CIPOS=0,100;PARID=a_o |

Would be returned as one entry:

| CHROM | ID  | POS  | REF | ALT       | FILTER | INFO                            | [`VariantType`](#varianttype) |
| ----- | --- | ---- | --- | --------- | ------ | ------------------------------- | ----------------------------- |
| 2     | a_o | 3010 | T   | T[3:5000[ | PASS   | SVTYPE=BND;CIPOS=0,50;PARID=a_h | TRN                           |


#### Single breakends
Single breakends cannot be matched with other breakends because they lack a mate. That is why each one is kept as a different variant. For example:

| CHROM | ID  | POS  | REF | ALT | FILTER | INFO       |
| ----- | --- | ---- | --- | --- | ------ | ---------- |
| 2     | a_s | 3000 | T   | T.  | PASS   | SVTYPE=BND |
| 3     | m_s | 5000 | G   | .G  | PASS   | SVTYPE=BND |

Would be returned as two entries:

| CHROM | ID  | POS  | REF | ALT | FILTER | INFO       | [`VariantType`](#varianttype) |
| ----- | --- | ---- | --- | --- | ------ | ---------- | ----------------------------- |
| 2     | a_s | 3000 | T   | T.  | PASS   | SVTYPE=BND | SGL                           |
| 3     | m_s | 5000 | G   | .G  | PASS   | SVTYPE=BND | SGL                           |
